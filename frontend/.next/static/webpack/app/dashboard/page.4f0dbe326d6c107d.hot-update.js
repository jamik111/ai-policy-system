"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./app/services/policyAPI.ts":
/*!***********************************!*\
  !*** ./app/services/policyAPI.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolicyAPIService: function() { return /* binding */ PolicyAPIService; },\n/* harmony export */   policyAPI: function() { return /* binding */ policyAPI; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// API Configuration\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8080/api\";\nconst WS_BASE_URL = process.env.NEXT_PUBLIC_WS_URL || \"ws://localhost:8080/api/stream\";\n// Policy API Service Class\nclass PolicyAPIService {\n    /**\r\n     * Initialize WebSocket connection\r\n     */ connectWebSocket(onMessage, onError, onClose) {\n        return new Promise((resolve, reject)=>{\n            if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {\n                resolve();\n                return;\n            }\n            this.isConnecting = true;\n            try {\n                this.ws = new WebSocket(WS_BASE_URL);\n                this.ws.onopen = ()=>{\n                    this.reconnectAttempts = 0;\n                    this.isConnecting = false;\n                    console.log(\"[PolicyAPI] WebSocket connected\");\n                    resolve();\n                };\n                this.ws.onmessage = (event)=>{\n                    try {\n                        const message = JSON.parse(event.data);\n                        onMessage(message);\n                        this.messageHandlers.forEach((handler)=>handler(message.payload));\n                    } catch (error) {\n                        console.error(\"[PolicyAPI] Failed to parse WebSocket message:\", error);\n                    }\n                };\n                this.ws.onerror = (error)=>{\n                    var _onError;\n                    this.isConnecting = false;\n                    console.error(\"[PolicyAPI] WebSocket error:\", error);\n                    (_onError = onError) === null || _onError === void 0 ? void 0 : _onError(error);\n                    reject(error);\n                };\n                this.ws.onclose = (event)=>{\n                    var _onClose;\n                    this.isConnecting = false;\n                    console.log(\"[PolicyAPI] WebSocket closed:\", event.code, event.reason);\n                    (_onClose = onClose) === null || _onClose === void 0 ? void 0 : _onClose(event);\n                    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n                        this.reconnectAttempts++;\n                        setTimeout(()=>{\n                            console.log(\"[PolicyAPI] Attempting reconnect (\".concat(this.reconnectAttempts, \"/\").concat(this.maxReconnectAttempts, \")...\"));\n                            this.connectWebSocket(onMessage, onError, onClose).catch(console.error);\n                        }, this.reconnectDelay * this.reconnectAttempts);\n                    }\n                };\n            } catch (error) {\n                this.isConnecting = false;\n                reject(error);\n            }\n        });\n    }\n    /**\r\n     * Disconnect WebSocket\r\n     */ disconnectWebSocket() {\n        if (this.ws) {\n            this.ws.close();\n            this.ws = null;\n        }\n        this.messageHandlers.clear();\n    }\n    /**\r\n     * Register handler for specific message types\r\n     */ onMessageType(type, handler) {\n        this.messageHandlers.set(type, handler);\n        return ()=>this.messageHandlers.delete(type);\n    }\n    /**\r\n     * Execute a task with policy evaluation\r\n     */ async executeTask(request) {\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/tasks/evaluate\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                agentId: request.agentId,\n                taskName: request.taskType,\n                payload: {\n                    input: request.input\n                },\n                userId: \"dashboard-user\",\n                simulationMode: false\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to execute task: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    /**\r\n     * Get audit logs with optional filtering\r\n     */ async getLogs(agentId) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (agentId) {\n            params.append(\"agentId\", agentId);\n        }\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/logs?\").concat(params.toString()));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch logs: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    /**\r\n     * Get system statistics\r\n     */ async getStatistics() {\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/statistics\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch statistics: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    /**\r\n     * Get system health status\r\n     */ async getHealth() {\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/health\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch health status: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    /**\r\n     * Get all active policies\r\n     */ async getPolicies() {\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/policies\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch policies: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    /**\r\n     * Get specific agent health status\r\n     */ async getAgentHealth(agentId) {\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/agents/\").concat(agentId, \"/health\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch agent health: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    /**\r\n     * Stream task execution updates\r\n     */ async *streamTaskUpdates(taskId) {\n        var _response_body;\n        const response = await this.fetchWithErrorHandling(\"\".concat(API_BASE_URL, \"/tasks/\").concat(taskId, \"/stream\"), {\n            method: \"GET\"\n        });\n        if (!response.ok) {\n            throw new Error(\"Failed to stream updates: \".concat(response.statusText));\n        }\n        const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n        if (!reader) {\n            throw new Error(\"Response body is not readable\");\n        }\n        const decoder = new TextDecoder();\n        let buffer = \"\";\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                buffer += decoder.decode(value, {\n                    stream: true\n                });\n                const lines = buffer.split(\"\\n\");\n                for(let i = 0; i < lines.length - 1; i++){\n                    const line = lines[i].trim();\n                    if (line) {\n                        try {\n                            const update = JSON.parse(line);\n                            yield update;\n                        } catch (error) {\n                            console.error(\"[PolicyAPI] Failed to parse stream update:\", error);\n                        }\n                    }\n                }\n                buffer = lines[lines.length - 1];\n            }\n            if (buffer.trim()) {\n                try {\n                    const update = JSON.parse(buffer);\n                    yield update;\n                } catch (error) {\n                    console.error(\"[PolicyAPI] Failed to parse final stream update:\", error);\n                }\n            }\n        } finally{\n            reader.releaseLock();\n        }\n    }\n    /**\r\n     * Internal method for fetch with error handling\r\n     */ async fetchWithErrorHandling(url) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const controller = new AbortController();\n        const timeout = setTimeout(()=>controller.abort(), 30000); // 30s timeout\n        try {\n            const response = await fetch(url, {\n                ...options,\n                signal: controller.signal\n            });\n            return response;\n        } catch (error) {\n            if (error instanceof Error) {\n                if (error.name === \"AbortError\") {\n                    throw new Error(\"Request timeout\");\n                }\n                throw new Error(\"Network error: \".concat(error.message));\n            }\n            throw error;\n        } finally{\n            clearTimeout(timeout);\n        }\n    }\n    constructor(){\n        this.ws = null;\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 5;\n        this.reconnectDelay = 3000;\n        this.messageHandlers = new Map();\n        this.isConnecting = false;\n    }\n}\n// Singleton instance\nconst policyAPI = new PolicyAPIService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9zZXJ2aWNlcy9wb2xpY3lBUEkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0JBQW9CO0FBQ3BCLE1BQU1BLGVBQWVDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7QUFDeEQsTUFBTUMsY0FBY0gsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRyxrQkFBa0IsSUFBSTtBQW1FdEQsMkJBQTJCO0FBQ3BCLE1BQU1DO0lBUVQ7O0tBRUMsR0FDREMsaUJBQ0lDLFNBQThDLEVBQzlDQyxPQUFnQyxFQUNoQ0MsT0FBcUMsRUFDeEI7UUFDYixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxJQUFJLENBQUNDLEVBQUUsSUFBSyxLQUFJLENBQUNBLEVBQUUsQ0FBQ0MsVUFBVSxLQUFLQyxVQUFVQyxJQUFJLElBQUksSUFBSSxDQUFDSCxFQUFFLENBQUNDLFVBQVUsS0FBS0MsVUFBVUUsVUFBVSxHQUFHO2dCQUNuR047Z0JBQ0E7WUFDSjtZQUVBLElBQUksQ0FBQ08sWUFBWSxHQUFHO1lBRXBCLElBQUk7Z0JBQ0EsSUFBSSxDQUFDTCxFQUFFLEdBQUcsSUFBSUUsVUFBVVo7Z0JBRXhCLElBQUksQ0FBQ1UsRUFBRSxDQUFDTSxNQUFNLEdBQUc7b0JBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztvQkFDekIsSUFBSSxDQUFDRixZQUFZLEdBQUc7b0JBQ3BCRyxRQUFRQyxHQUFHLENBQUM7b0JBQ1pYO2dCQUNKO2dCQUVBLElBQUksQ0FBQ0UsRUFBRSxDQUFDVSxTQUFTLEdBQUcsQ0FBQ0M7b0JBQ2pCLElBQUk7d0JBQ0EsTUFBTUMsVUFBNEJDLEtBQUtDLEtBQUssQ0FBQ0gsTUFBTUksSUFBSTt3QkFDdkRyQixVQUFVa0I7d0JBQ1YsSUFBSSxDQUFDSSxlQUFlLENBQUNDLE9BQU8sQ0FBQyxDQUFDQyxVQUFZQSxRQUFRTixRQUFRTyxPQUFPO29CQUNyRSxFQUFFLE9BQU9DLE9BQU87d0JBQ1pa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QUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvc2VydmljZXMvcG9saWN5QVBJLnRzPzczNjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQVBJIENvbmZpZ3VyYXRpb25cclxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDgwL2FwaSc7XHJcbmNvbnN0IFdTX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfV1NfVVJMIHx8ICd3czovL2xvY2FsaG9zdDo4MDgwL2FwaS9zdHJlYW0nO1xyXG5cclxuLy8gVHlwZSBkZWZpbml0aW9uc1xyXG5leHBvcnQgaW50ZXJmYWNlIFRhc2tSZXF1ZXN0IHtcclxuICAgIGFnZW50SWQ6IHN0cmluZztcclxuICAgIHRhc2tUeXBlOiBzdHJpbmc7XHJcbiAgICBpbnB1dDogc3RyaW5nO1xyXG4gICAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhc2tSZXNwb25zZSB7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgc3RhdHVzOiAncGVuZGluZycgfCAncnVubmluZycgfCAnY29tcGxldGVkJyB8ICdmYWlsZWQnIHwgJ2Jsb2NrZWQnO1xyXG4gICAgcmVzdWx0OiB7XHJcbiAgICAgICAgZGVjaXNpb246ICdhbGxvdycgfCAnZGVueSc7XHJcbiAgICAgICAgY29uZmlkZW5jZTogbnVtYmVyO1xyXG4gICAgICAgIHJ1bGVzVHJpZ2dlcmVkOiBzdHJpbmdbXTtcclxuICAgICAgICBkdXJhdGlvbjogbnVtYmVyO1xyXG4gICAgfTtcclxuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gICAgYWdlbnRJZDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFnZW50SGVhbHRoIHtcclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAnb2ZmbGluZSc7XHJcbiAgICBtZXRyaWNzOiB7XHJcbiAgICAgICAgY3B1OiBudW1iZXI7XHJcbiAgICAgICAgbWVtb3J5OiBudW1iZXI7XHJcbiAgICAgICAgcmVxdWVzdHNQZXJNaW51dGU/OiBudW1iZXI7XHJcbiAgICB9O1xyXG4gICAgdGFza3NQcm9jZXNzZWQ6IG51bWJlcjtcclxuICAgIHN1Y2Nlc3NSYXRlOiBudW1iZXI7XHJcbiAgICBsYXN0SGVhcnRiZWF0OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoU3RhdHVzIHtcclxuICAgIHN0YXR1czogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICdvZmZsaW5lJztcclxuICAgIGFnZW50czogQWdlbnRIZWFsdGhbXTtcclxuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY3Mge1xyXG4gICAgdG90YWxUYXNrczogbnVtYmVyO1xyXG4gICAgdG90YWxWaW9sYXRpb25zOiBudW1iZXI7XHJcbiAgICBzdWNjZXNzUmF0ZTogbnVtYmVyO1xyXG4gICAgYXZlcmFnZVJlc3BvbnNlVGltZTogbnVtYmVyO1xyXG4gICAgdGltZXN0YW1wOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXVkaXRMb2cge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xyXG4gICAgYWN0aW9uOiBzdHJpbmc7XHJcbiAgICBkZWNpc2lvbjogJ2FsbG93JyB8ICdkZW55JztcclxuICAgIGFnZW50SWQ6IHN0cmluZztcclxuICAgIGRldGFpbHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdlYlNvY2tldE1lc3NhZ2Uge1xyXG4gICAgdHlwZTogJ2xvZycgfCAnaGVhbHRoJyB8ICdzdGF0cycgfCAnYWdlbnQtdXBkYXRlJyB8ICdlcnJvcicgfCAnaW5pdCcgfCAndXBkYXRlJztcclxuICAgIHBheWxvYWQ/OiBhbnk7XHJcbiAgICBkYXRhPzogYW55O1xyXG4gICAgdGltZXN0YW1wPzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBQb2xpY3kgQVBJIFNlcnZpY2UgQ2xhc3NcclxuZXhwb3J0IGNsYXNzIFBvbGljeUFQSVNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgIHByaXZhdGUgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSA1O1xyXG4gICAgcHJpdmF0ZSByZWNvbm5lY3REZWxheSA9IDMwMDA7XHJcbiAgICBwcml2YXRlIG1lc3NhZ2VIYW5kbGVyczogTWFwPHN0cmluZywgKHBheWxvYWQ6IGFueSkgPT4gdm9pZD4gPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIGlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBXZWJTb2NrZXQgY29ubmVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb25uZWN0V2ViU29ja2V0KFxyXG4gICAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2U6IFdlYlNvY2tldE1lc3NhZ2UpID0+IHZvaWQsXHJcbiAgICAgICAgb25FcnJvcj86IChlcnJvcjogRXZlbnQpID0+IHZvaWQsXHJcbiAgICAgICAgb25DbG9zZT86IChldmVudDogQ2xvc2VFdmVudCkgPT4gdm9pZFxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMud3MgJiYgKHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gfHwgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0Nvbm5lY3RpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KFdTX0JBU0VfVVJMKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbUG9saWN5QVBJXSBXZWJTb2NrZXQgY29ubmVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZTogV2ViU29ja2V0TWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4gaGFuZGxlcihtZXNzYWdlLnBheWxvYWQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUG9saWN5QVBJXSBGYWlsZWQgdG8gcGFyc2UgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy53cy5vbmVycm9yID0gKGVycm9yOiBFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1BvbGljeUFQSV0gV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yPy4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMud3Mub25jbG9zZSA9IChldmVudDogQ2xvc2VFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tQb2xpY3lBUEldIFdlYlNvY2tldCBjbG9zZWQ6JywgZXZlbnQuY29kZSwgZXZlbnQucmVhc29uKTtcclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPy4oZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA8IHRoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBbUG9saWN5QVBJXSBBdHRlbXB0aW5nIHJlY29ubmVjdCAoJHt0aGlzLnJlY29ubmVjdEF0dGVtcHRzfS8ke3RoaXMubWF4UmVjb25uZWN0QXR0ZW1wdHN9KS4uLmBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RXZWJTb2NrZXQob25NZXNzYWdlLCBvbkVycm9yLCBvbkNsb3NlKS5jYXRjaChjb25zb2xlLmVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5yZWNvbm5lY3REZWxheSAqIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzY29ubmVjdCBXZWJTb2NrZXRcclxuICAgICAqL1xyXG4gICAgZGlzY29ubmVjdFdlYlNvY2tldCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy53cykge1xyXG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMud3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgaGFuZGxlciBmb3Igc3BlY2lmaWMgbWVzc2FnZSB0eXBlc1xyXG4gICAgICovXHJcbiAgICBvbk1lc3NhZ2VUeXBlKHR5cGU6IHN0cmluZywgaGFuZGxlcjogKHBheWxvYWQ6IGFueSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLnNldCh0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5tZXNzYWdlSGFuZGxlcnMuZGVsZXRlKHR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZSBhIHRhc2sgd2l0aCBwb2xpY3kgZXZhbHVhdGlvblxyXG4gICAgICovXHJcbiAgICBhc3luYyBleGVjdXRlVGFzayhyZXF1ZXN0OiBUYXNrUmVxdWVzdCk6IFByb21pc2U8VGFza1Jlc3BvbnNlPiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEVycm9ySGFuZGxpbmcoXHJcbiAgICAgICAgICAgIGAke0FQSV9CQVNFX1VSTH0vdGFza3MvZXZhbHVhdGVgLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGFnZW50SWQ6IHJlcXVlc3QuYWdlbnRJZCxcclxuICAgICAgICAgICAgICAgICAgICB0YXNrTmFtZTogcmVxdWVzdC50YXNrVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IGlucHV0OiByZXF1ZXN0LmlucHV0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkOiAnZGFzaGJvYXJkLXVzZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpbXVsYXRpb25Nb2RlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgdGFzazogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhdWRpdCBsb2dzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldExvZ3MoXHJcbiAgICAgICAgYWdlbnRJZD86IHN0cmluZyxcclxuICAgICAgICBsaW1pdDogbnVtYmVyID0gNTAsXHJcbiAgICAgICAgb2Zmc2V0OiBudW1iZXIgPSAwXHJcbiAgICApOiBQcm9taXNlPEF1ZGl0TG9nW10+IHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChhZ2VudElkKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoJ2FnZW50SWQnLCBhZ2VudElkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhFcnJvckhhbmRsaW5nKFxyXG4gICAgICAgICAgICBgJHtBUElfQkFTRV9VUkx9L2xvZ3M/JHtwYXJhbXMudG9TdHJpbmcoKX1gXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBsb2dzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHN5c3RlbSBzdGF0aXN0aWNzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFN0YXRpc3RpY3MoKTogUHJvbWlzZTxTdGF0aXN0aWNzPiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEVycm9ySGFuZGxpbmcoXHJcbiAgICAgICAgICAgIGAke0FQSV9CQVNFX1VSTH0vc3RhdGlzdGljc2BcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHN0YXRpc3RpY3M6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgc3lzdGVtIGhlYWx0aCBzdGF0dXNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0SGVhbHRoKCk6IFByb21pc2U8SGVhbHRoU3RhdHVzPiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEVycm9ySGFuZGxpbmcoXHJcbiAgICAgICAgICAgIGAke0FQSV9CQVNFX1VSTH0vaGVhbHRoYFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaGVhbHRoIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgYWN0aXZlIHBvbGljaWVzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFBvbGljaWVzKCk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgYW55PltdPiB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aEVycm9ySGFuZGxpbmcoXHJcbiAgICAgICAgICAgIGAke0FQSV9CQVNFX1VSTH0vcG9saWNpZXNgXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBwb2xpY2llczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzcGVjaWZpYyBhZ2VudCBoZWFsdGggc3RhdHVzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFnZW50SGVhbHRoKGFnZW50SWQ6IHN0cmluZyk6IFByb21pc2U8QWdlbnRIZWFsdGg+IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhcclxuICAgICAgICAgICAgYCR7QVBJX0JBU0VfVVJMfS9hZ2VudHMvJHthZ2VudElkfS9oZWFsdGhgXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBhZ2VudCBoZWFsdGg6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJlYW0gdGFzayBleGVjdXRpb24gdXBkYXRlc1xyXG4gICAgICovXHJcbiAgICBhc3luYyAqc3RyZWFtVGFza1VwZGF0ZXModGFza0lkOiBzdHJpbmcpOiBBc3luY0dlbmVyYXRvcjxUYXNrUmVzcG9uc2U+IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhcclxuICAgICAgICAgICAgYCR7QVBJX0JBU0VfVVJMfS90YXNrcy8ke3Rhc2tJZH0vc3RyZWFtYCxcclxuICAgICAgICAgICAgeyBtZXRob2Q6ICdHRVQnIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHN0cmVhbSB1cGRhdGVzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcclxuICAgICAgICBpZiAoIXJlYWRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgbm90IHJlYWRhYmxlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb25lKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoJ1xcbicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gSlNPTi5wYXJzZShsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHVwZGF0ZSBhcyBUYXNrUmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUG9saWN5QVBJXSBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHVwZGF0ZTonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChidWZmZXIudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IEpTT04ucGFyc2UoYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB1cGRhdGUgYXMgVGFza1Jlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUG9saWN5QVBJXSBGYWlsZWQgdG8gcGFyc2UgZmluYWwgc3RyZWFtIHVwZGF0ZTonLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIGZldGNoIHdpdGggZXJyb3IgaGFuZGxpbmdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBmZXRjaFdpdGhFcnJvckhhbmRsaW5nKFxyXG4gICAgICAgIHVybDogc3RyaW5nLFxyXG4gICAgICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cclxuICAgICk6IFByb21pc2U8UmVzcG9uc2U+IHtcclxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgMzAwMDApOyAvLyAzMHMgdGltZW91dFxyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xyXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmV0d29yayBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIFNpbmdsZXRvbiBpbnN0YW5jZVxyXG5leHBvcnQgY29uc3QgcG9saWN5QVBJID0gbmV3IFBvbGljeUFQSVNlcnZpY2UoKTtcclxuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiV1NfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19XU19VUkwiLCJQb2xpY3lBUElTZXJ2aWNlIiwiY29ubmVjdFdlYlNvY2tldCIsIm9uTWVzc2FnZSIsIm9uRXJyb3IiLCJvbkNsb3NlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ3cyIsInJlYWR5U3RhdGUiLCJXZWJTb2NrZXQiLCJPUEVOIiwiQ09OTkVDVElORyIsImlzQ29ubmVjdGluZyIsIm9ub3BlbiIsInJlY29ubmVjdEF0dGVtcHRzIiwiY29uc29sZSIsImxvZyIsIm9ubWVzc2FnZSIsImV2ZW50IiwibWVzc2FnZSIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJtZXNzYWdlSGFuZGxlcnMiLCJmb3JFYWNoIiwiaGFuZGxlciIsInBheWxvYWQiLCJlcnJvciIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiY29kZSIsInJlYXNvbiIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwic2V0VGltZW91dCIsImNhdGNoIiwicmVjb25uZWN0RGVsYXkiLCJkaXNjb25uZWN0V2ViU29ja2V0IiwiY2xvc2UiLCJjbGVhciIsIm9uTWVzc2FnZVR5cGUiLCJ0eXBlIiwic2V0IiwiZGVsZXRlIiwiZXhlY3V0ZVRhc2siLCJyZXF1ZXN0IiwicmVzcG9uc2UiLCJmZXRjaFdpdGhFcnJvckhhbmRsaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJzdHJpbmdpZnkiLCJhZ2VudElkIiwidGFza05hbWUiLCJ0YXNrVHlwZSIsImlucHV0IiwidXNlcklkIiwic2ltdWxhdGlvbk1vZGUiLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImpzb24iLCJnZXRMb2dzIiwibGltaXQiLCJvZmZzZXQiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b1N0cmluZyIsImFwcGVuZCIsImdldFN0YXRpc3RpY3MiLCJnZXRIZWFsdGgiLCJnZXRQb2xpY2llcyIsImdldEFnZW50SGVhbHRoIiwic3RyZWFtVGFza1VwZGF0ZXMiLCJ0YXNrSWQiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZGVjb2RlIiwic3RyZWFtIiwibGluZXMiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJsaW5lIiwidHJpbSIsInVwZGF0ZSIsInJlbGVhc2VMb2NrIiwidXJsIiwib3B0aW9ucyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0IiwiYWJvcnQiLCJmZXRjaCIsInNpZ25hbCIsIm5hbWUiLCJjbGVhclRpbWVvdXQiLCJNYXAiLCJwb2xpY3lBUEkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/services/policyAPI.ts\n"));

/***/ })

});